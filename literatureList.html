<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>认知科学图书论文列表</title>
<style>
  body {
    margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #3e2f1c; color: #f0e6d2;
    user-select: none;
  }
  header {
    background: #5a432a; text-align: center; padding: 1rem;
    font-size: 1.5rem; font-weight: bold;
    color: #e1d6b9;
    box-shadow: 0 2px 5px rgba(0,0,0,0.7);
  }
  main {
    height: calc(100vh - 120px);
    position: relative;
    overflow: hidden;
  }
  section {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    padding: 1rem;
    overflow-y: auto;
    background: #4e3b24;
    border-radius: 10px;
    box-shadow: inset 0 0 20px #2a1f0f;
    transition: opacity 0.5s ease;
  }
  section.hidden {
    opacity: 0; pointer-events: none;
  }
  #search-page {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    height: 100%;
  }
  input[type="text"], input[type="number"] {
    width: 240px; padding: 8px; border-radius: 6px; border: none;
    margin-right: 10px; font-size: 1rem;
  }
  button {
    background: #6f553b; color: #e1d6b9;
    border: none; padding: 8px 16px;
    border-radius: 6px; cursor: pointer;
    font-weight: 600;
    box-shadow: 0 3px 0 #4a3b2a;
    transition: background-color 0.3s;
  }
  button:hover {
    background: #947a56;
  }
  button:disabled {
    background: #806a4c;
    cursor: not-allowed;
    box-shadow: none;
  }
  table {
    width: 100%; border-collapse: separate;
    border-spacing: 0;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 10px #261b0f;
  }
  th, td {
    padding: 10px 12px;
    text-align: left;
    background: #5a442a;
    border-bottom: 1px solid #7f6645;
  }
  th.sortable {
    cursor: pointer;
    user-select: none;
  }
  th.sortable:hover {
    background: #806c47;
  }
  th, td:last-child {
    text-align: center;
  }
  tr:hover {
    background: #6f5634;
  }
  tbody tr:last-child td {
    border-bottom: none;
  }
  tbody tr td:first-child {
    width: 30px;
    text-align: center;
  }
  tbody tr td:nth-last-child(2) {
    width: 110px;
  }
  tbody tr td:nth-last-child(1) {
    width: 70px;
  }
  #list-page {
    padding-bottom: 60px; /* 为选择栏留出空间 */
  }

  #selection-bar {
    position: fixed;
    bottom: 60px; /* 调整到footer上方 */
    left: 10px;
    right: 10px;
    background: #5a442a;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0 0 15px #3a2b1a;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    color: #e1d6b9;
    z-index: 10; /* 确保在选择栏上方 */
  }

  main {
    height: calc(100vh - 120px);
    position: relative;
    overflow: hidden;
  }
  #selection-bar button {
    padding: 5px 12px;
    font-size: 13px;
  }
  footer {
    position: fixed; bottom: 0; left: 0; right: 0;
    height: 60px;
    background: #5a432a;
    display: flex;
    border-radius: 10px 10px 0 0;
    box-shadow: 0 -2px 5px rgba(0,0,0,0.7);
    user-select: none;
  }
  .tab {
    flex: 1;
    text-align: center;
    line-height: 60px;
    font-weight: 600;
    font-size: 1.1rem;
    color: #b09a73;
    cursor: pointer;
    position: relative;
    z-index: 1;
  }
  .tab.active {
    color: #3e2f1c;
  }
  #slider {
    position: absolute;
    bottom: 0; left: 0;
    height: 60px;
    width: 50%;
    background: #b09a73;
    border-radius: 10px 10px 0 0;
    transition: left 0.3s ease;
    z-index: 0;
    cursor: grab;
  }
  #slider:active {
    cursor: grabbing;
  }
  /* 让遮罩层仍然居中，但给底部留出 footer 安全距离（60px + 额外 16px） */
#modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(62, 47, 28, 0.85);
  display: flex;
  justify-content: center;
  align-items: center;     /* 中部 */
  padding: 16px 16px 76px; /* 底部安全边距，避免视觉上“超出网页” */
  opacity: 0; pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 1000;
}

#modal-overlay.show {
    opacity: 1; pointer-events: auto;
  }
  

/* 弹窗本体：限制最大高度，超出时内部滚动 */
#modal {
  background: #7f684a;
  padding: 20px;
  border-radius: 12px;
  width: clamp(320px, 90vw, 520px);
  max-height: calc(100vh - 120px); /* 不超过可视区（含上下留白） */
  overflow-y: auto;                 /* 内容过多时内滚，不撑破屏幕 */
  box-shadow: 0 0 15px #4a3b2a;
  color: #f0e6d2;
}

  #modal label {
    display: block;
    margin-top: 10px;
    font-weight: 600;
  }
  #modal input[type="text"], #modal input[type="number"], #modal select {
    width: 100%;
    padding: 6px;
    border-radius: 6px;
    border: none;
    margin-top: 5px;
    font-size: 1rem;
    background: #a49071;
    color: #3e2f1c;
    font-weight: 600;
  }
  #modal select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    cursor: pointer;
  }
  #modal-buttons {
    margin-top: 15px;
    text-align: right;
  }
  #modal-buttons button {
    margin-left: 10px;
  }
  #toast {
    position: fixed;
    bottom: 140px;
    left: 50%;
    transform: translateX(-50%);
    background: #b09a73cc;
    color: #3e2f1c;
    padding: 12px 30px;
    border-radius: 25px;
    font-weight: 600;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 1100;
  }
  #toast.show {
    opacity: 1;
    pointer-events: auto;
  }
</style>
</head>
<body>
<header>图书论文管理</header>

<main>
  <section id="search-page">
    <div>
      <input type="text" id="isbn-input" placeholder="输入ISBN号搜索图书" />
      <button id="btn-isbn-search">搜索图书</button>
    </div>
    <div>
      <input type="text" id="doi-input" placeholder="输入论文DOI搜索论文" />
      <button id="btn-doi-search">搜索论文</button>
    </div>
  </section>

  <section id="list-page" class="hidden">
    <div style="margin-bottom:10px;">
      <input type="text" id="filter-input" placeholder="搜索列表内容..." style="width: 100%; padding: 8px; border-radius: 6px; border: none; font-size: 1rem;" />
    </div>
    <table>
      <thead>
        <tr>
          <th><input type="checkbox" id="select-all"></th>
          <th class="sortable" data-field="type">类型</th>
          <th class="sortable" data-field="id">编号</th>
          <th class="sortable" data-field="title">标题</th>
          <th class="sortable" data-field="authors">作者</th>
          <th class="sortable" data-field="publisher">出版社/期刊</th>
          <th class="sortable" data-field="publishDate">出版/发表日期</th>
          <th class="sortable" data-field="progress">阅读进度</th>
          <th style="width: 70px;">操作</th>
        </tr>
      </thead>
      <tbody id="list-body"></tbody>
    </table>
    <div id="selection-bar" hidden>
      已选中 <span id="selected-count">0</span> 条
      <button id="btn-select-all">全选</button>
      <button id="btn-select-inverse">反选</button>
      <button id="btn-clear-selection">清除选择</button>
      <button id="btn-delete-selected">删除选中</button>
      <button id="btn-export-selected">导出选中</button>
      <button id="btn-export-all">导出全部</button>
    </div>
  </section>
</main>

<footer>
  <div class="tab active" data-index="0">搜索</div>
  <div class="tab" data-index="1">列表</div>
  <div id="slider"></div>
</footer>

<div id="modal-overlay">
  <form id="modal">
    <h3 id="modal-title">编辑条目</h3>
    <label>类型
      <select id="modal-type">
        <option value="图书">图书</option>
        <option value="论文">论文</option>
      </select>
    </label>
    <label>编号 (不可修改)
      <input type="text" id="modal-id" readonly />
    </label>
    <label>标题 *
      <input type="text" id="modal-title-input" required />
    </label>
    <label>作者 *
      <input type="text" id="modal-authors-input" required />
    </label>
    <label>出版社/期刊
      <input type="text" id="modal-publisher-input" />
    </label>
    <label>出版/发表日期
      <input type="text" id="modal-publish-date-input" />
    </label>
    <label>总页数
      <input type="number" id="modal-total-pages" min="0" />
    </label>
    <label>已读页数
      <input type="number" id="modal-read-pages" min="0" />
    </label>
    <div id="modal-buttons">
      <button type="submit">保存</button>
      <button type="button" id="modal-close-btn">取消</button>
    </div>
  </form>
</div>

<div id="toast"></div>

<script>
(() => {
  const isbnInput = document.getElementById('isbn-input');
  const btnIsbnSearch = document.getElementById('btn-isbn-search');
  const doiInput = document.getElementById('doi-input');
  const btnDoiSearch = document.getElementById('btn-doi-search');
  const searchPage = document.getElementById('search-page');
  const listPage = document.getElementById('list-page');
  const filterInput = document.getElementById('filter-input');
  const listBody = document.getElementById('list-body');
  const selectAllCheckbox = document.getElementById('select-all');
  const selectionBar = document.getElementById('selection-bar');
  const selectedCount = document.getElementById('selected-count');
  const btnSelectAll = document.getElementById('btn-select-all');
  const btnSelectInverse = document.getElementById('btn-select-inverse');
  const btnClearSelection = document.getElementById('btn-clear-selection');
  const btnDeleteSelected = document.getElementById('btn-delete-selected');
  const btnExportSelected = document.getElementById('btn-export-selected');
  const btnExportAll = document.getElementById('btn-export-all');

  const modalOverlay = document.getElementById('modal-overlay');
  const modalForm = document.getElementById('modal');
  const modalType = document.getElementById('modal-type');
  const modalIdInput = document.getElementById('modal-id');
  const modalTitleInput = document.getElementById('modal-title-input');
  const modalAuthorsInput = document.getElementById('modal-authors-input');
  const modalPublisherInput = document.getElementById('modal-publisher-input');
  const modalPublishDateInput = document.getElementById('modal-publish-date-input');
  const modalTotalPages = document.getElementById('modal-total-pages');
  const modalReadPages = document.getElementById('modal-read-pages');
  const modalCloseBtn = document.getElementById('modal-close-btn');
  const toast = document.getElementById('toast');

  const tabs = document.querySelectorAll('.tab');
  const slider = document.getElementById('slider');

  let currentTab = 0;
  let books = [];
  let selection = new Map();
  let currentSort = { field: '', direction: 1 };

  function switchTab(index) {
    if (index === currentTab) return;
    currentTab = index;
    if (currentTab === 0) {
      searchPage.classList.remove('hidden');
      listPage.classList.add('hidden');
    } else {
      listPage.classList.remove('hidden');
      searchPage.classList.add('hidden');
    }
    tabs.forEach((tab, i) => {
      tab.classList.toggle('active', i === currentTab);
    });
    slider.style.left = `${currentTab * 50}%`;
  }
  slider.style.width = '50%';
  slider.style.left = '0';
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      switchTab(Number(tab.dataset.index));
    });
  });

async function fetchBookInfo(isbn) {
  const cleanIsbn = isbn.trim();
  if (!cleanIsbn) return null;

  // --- Open Library ---
  try {
    const res = await fetch(`https://openlibrary.org/isbn/${cleanIsbn}.json`);
    if (res.ok) {
      const data = await res.json();
      return {
        source: 'OpenLibrary',
        type: '图书',
        id: cleanIsbn,
        title: data.title || '',
        authors: (data.authors || []).map(a => a.name).join(', '),
        publisher: (data.publishers || []).join(', '),
        publishDate: data.publish_date || '',
        totalPages: data.number_of_pages || '',
        readPages: '',
        progress: 0
      };
    }
  } catch {}

  // --- Google Books ---
  try {
    const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${cleanIsbn}`);
    if (res.ok) {
      const data = await res.json();
      if (data?.items && data.items.length > 0) {
        const volume = data.items[0].volumeInfo;
        return {
          source: 'GoogleBooks',
          type: '图书',
          id: cleanIsbn,
          title: volume.title || '',
          authors: (volume.authors || []).join(', '),
          publisher: volume.publisher || '',
          publishDate: volume.publishedDate || '',
          totalPages: volume.pageCount || '',
          readPages: '',
          progress: 0
        };
      }
    }
  } catch {}

  // --- ISBNdb (可选) ---
  // try {
  //   const res = await fetch(`https://api2.isbndb.com/book/${cleanIsbn}`, {
  //     headers: { 'Authorization': 'YOUR_API_KEY' }
  //   });
  //   if (res.ok) {
  //     const data = await res.json();
  //     const book = data?.book;
  //     if (book) {
  //       return {
  //         source: 'ISBNdb',
  //         type: '图书',
  //         id: cleanIsbn,
  //         title: book.title || '',
  //         authors: (book.authors || []).join(', '),
  //         publisher: book.publisher || '',
  //         publishDate: book.date_published || '',
  //         totalPages: book.pages || '',
  //         readPages: '',
  //         progress: 0
  //       };
  //     }
  //   }
  // } catch {}

  return null; // 如果都没找到
}

  

  async function fetchPaperInfo(doi) {
    const cleanDoi = doi.trim().toLowerCase();
    if (!cleanDoi) return null;

    const crossRefFetch = fetch(`https://api.crossref.org/works/${encodeURIComponent(cleanDoi)}`)
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        const m = data?.message;
        if (!m) return null;
        return {
          source: 'CrossRef',
          type: '论文',
          id: cleanDoi,
          title: Array.isArray(m.title) ? m.title[0] : m.title || '',
          authors: m.author ? m.author.map(a => `${a.given || ''} ${a.family || ''}`.trim()).join(', ') : '',
          publisher: m['container-title'] ? m['container-title'][0] : '',
          publishDate: m.published && m.published['date-parts'] ? m.published['date-parts'][0].join('-') : '',
          totalPages: '',
          readPages: '',
          progress: 0
        };
      }).catch(() => null);

    const semanticScholarFetch = fetch(`https://api.semanticscholar.org/graph/v1/paper/${encodeURIComponent(cleanDoi)}?fields=title,authors,venue,year`)
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (!data?.title) return null;
        return {
          source: 'SemanticScholar',
          type: '论文',
          id: cleanDoi,
          title: data.title || '',
          authors: data.authors ? data.authors.map(a => a.name).join(', ') : '',
          publisher: data.venue || '',
          publishDate: data.year ? String(data.year) : '',
          totalPages: '',
          readPages: '',
          progress: 0
        };
      }).catch(() => null);

    const results = await Promise.allSettled([crossRefFetch, semanticScholarFetch]);
    const papersResults = results.filter(r => r.status === 'fulfilled' && r.value !== null).map(r => r.value);
    if (papersResults.length === 0) return null;

    const merged = {};
    for (const p of papersResults) {
      merged.type = p.type;
      merged.id = p.id;
      merged.title = merged.title || p.title;
      merged.authors = merged.authors || p.authors;
      merged.publisher = merged.publisher || p.publisher;
      merged.publishDate = merged.publishDate || p.publishDate;
      merged.totalPages = '';
      merged.readPages = '';
      merged.progress = 0;
    }
    return merged;
  }

  function addBook(item) {
  const exists = books.some(b => b.id === item.id);
  if (exists) {
    if (confirm('该条目已在列表中，确定重复添加？\n\n选择“舍弃”将不会添加，选择“确定”将会重复添加。')) {
      books.push(item);
      saveBooks();
      renderTable(filterInput.value);
      showToast('条目已重复添加');
    } else {
      showToast('添加已舍弃');
    }
  } else {
    books.push(item);
    saveBooks();
    renderTable(filterInput.value);
    showToast('条目已添加');
  }
}


  function saveBooks() {
    localStorage.setItem('booksData', JSON.stringify(books));
  }

  function renderTable(filter) {
    const f = filter.trim().toLowerCase();
    listBody.innerHTML = '';
    selection.clear();
    let filtered = books.filter(b => {
      return !f || Object.values(b).some(val => val && val.toString().toLowerCase().includes(f));
    });
    if (currentSort.field) {
      filtered.sort((a, b) => {
        let va = a[currentSort.field] || '';
        let vb = b[currentSort.field] || '';
        va = va.toString().toLowerCase();
        vb = vb.toString().toLowerCase();
        if (va < vb) return -1 * currentSort.direction;
        if (va > vb) return 1 * currentSort.direction;
        return 0;
      });
    }
    filtered.forEach(b => {
      const tr = document.createElement('tr');
      const tdCheck = document.createElement('td');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.dataset.id = b.id;
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) selection.set(b.id, b);
        else selection.delete(b.id);
        updateSelectionBar();
        updateSelectAllCheckbox();
      });
      tdCheck.appendChild(checkbox);
      tr.appendChild(tdCheck);

      ['type', 'id', 'title', 'authors', 'publisher', 'publishDate'].forEach(key => {
        const td = document.createElement('td');
        td.textContent = b[key] || '';
        tr.appendChild(td);
      });

      // 阅读进度栏，显示进度条
     // 阅读进度栏，显示进度条+百分比文本
	const tdProgress = document.createElement('td');
	const progressBarContainer = document.createElement('div');
	progressBarContainer.style.position = 'relative';   // 相对定位，方便内部文字绝对定位
	progressBarContainer.style.background = '#806c47';
	progressBarContainer.style.borderRadius = '10px';
	progressBarContainer.style.height = '18px';          // 稍高一点，为文本留空间
	progressBarContainer.style.width = '100px';
	progressBarContainer.style.margin = '4px auto';

	const progressBar = document.createElement('div');
	progressBar.style.height = '100%';
	progressBar.style.width = `${b.progress || 0}%`;
	progressBar.style.background = '#b09a73';
	progressBar.style.borderRadius = '10px 0 0 10px';

	const progressText = document.createElement('div');
	progressText.textContent = `${b.progress || 0}%`;
	progressText.style.position = 'absolute';
	progressText.style.top = '50%';
	progressText.style.left = '50%';
	progressText.style.transform = 'translate(-50%, -50%)';
	progressText.style.color = '#3e2f1c';
	progressText.style.fontWeight = '700';
	progressText.style.fontSize = '12px';
	progressText.style.userSelect = 'none';

	progressBarContainer.appendChild(progressBar);
	progressBarContainer.appendChild(progressText);
	tdProgress.appendChild(progressBarContainer);
	tr.appendChild(tdProgress);


      const tdEdit = document.createElement('td');
      const editBtn = document.createElement('button');
      editBtn.textContent = '编辑';
      editBtn.style.padding = '2px 8px';
      editBtn.style.fontSize = '12px';
      editBtn.addEventListener('click', () => openEditModal(b));
      tdEdit.appendChild(editBtn);
      tr.appendChild(tdEdit);

      listBody.appendChild(tr);
    });
    updateSelectionBar();
    updateSelectAllCheckbox();
  }

  function updateSelectionBar() {
    const count = selection.size;
    if (count > 0) {
      selectionBar.hidden = false;
      selectedCount.textContent = count;
    } else {
      selectionBar.hidden = true;
    }
  }

  function updateSelectAllCheckbox() {
    const allCheckboxes = listBody.querySelectorAll('input[type=checkbox]');
    if (allCheckboxes.length === 0) {
      selectAllCheckbox.checked = false;
      selectAllCheckbox.indeterminate = false;
      return;
    }
    const checkedCount = Array.from(allCheckboxes).filter(cb => cb.checked).length;
    if (checkedCount === allCheckboxes.length) {
      selectAllCheckbox.checked = true;
      selectAllCheckbox.indeterminate = false;
    } else if (checkedCount > 0) {
      selectAllCheckbox.checked = false;
      selectAllCheckbox.indeterminate = true;
    } else {
      selectAllCheckbox.checked = false;
      selectAllCheckbox.indeterminate = false;
    }
  }

  selectAllCheckbox.addEventListener('change', () => {
    const checked = selectAllCheckbox.checked;
    listBody.querySelectorAll('input[type=checkbox]').forEach(cb => {
      cb.checked = checked;
      if (checked) {
        const id = cb.dataset.id;
        const book = books.find(b => b.id === id);
        if (book) selection.set(id, book);
      } else {
        selection.clear();
      }
    });
    updateSelectionBar();
  });

  btnSelectAll.addEventListener('click', () => {
    listBody.querySelectorAll('input[type=checkbox]').forEach(cb => {
      cb.checked = true;
      const id = cb.dataset.id;
      const book = books.find(b => b.id === id);
      if (book) selection.set(id, book);
    });
    updateSelectionBar();
    updateSelectAllCheckbox();
  });

  btnSelectInverse.addEventListener('click', () => {
    listBody.querySelectorAll('input[type=checkbox]').forEach(cb => {
      cb.checked = !cb.checked;
      const id = cb.dataset.id;
      if (cb.checked) {
        const book = books.find(b => b.id === id);
        if (book) selection.set(id, book);
      } else {
        selection.delete(id);
      }
    });
    updateSelectionBar();
    updateSelectAllCheckbox();
  });

  btnClearSelection.addEventListener('click', () => {
    selection.clear();
    listBody.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = false);
    updateSelectionBar();
    updateSelectAllCheckbox();
  });

  btnDeleteSelected.addEventListener('click', () => {
    if (!confirm(`确定删除选中的 ${selection.size} 条记录？`)) return;
    books = books.filter(b => !selection.has(b.id));
    selection.clear();
    saveBooks();
    renderTable(filterInput.value);
  });

  function exportCSV(data) {
    if (data.length === 0) {
      alert('没有可导出的数据');
      return;
    }
    const header = ['类型', '编号', '标题', '作者', '出版社/期刊', '出版/发表日期', '总页数', '已读页数', '阅读进度(%)'];
    const rows = data.map(d => [
      d.type, d.id, d.title, d.authors, d.publisher, d.publishDate,
      d.totalPages || '', d.readPages || '', d.progress || 0
    ]);
    let csvContent = header.join(',') + '\n' +
      rows.map(r => r.map(cell => `"${(cell||'').toString().replace(/"/g, '""')}"`).join(',')).join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'export.csv';
    a.click();
  }

  btnExportSelected.addEventListener('click', () => {
    exportCSV(Array.from(selection.values()));
  });

  btnExportAll.addEventListener('click', () => {
    exportCSV(books);
  });

  filterInput.addEventListener('input', () => {
    renderTable(filterInput.value);
  });

  function openEditModal(item) {
    modalType.value = item.type;
    modalIdInput.value = item.id;
    modalTitleInput.value = item.title;
    modalAuthorsInput.value = item.authors;
    modalPublisherInput.value = item.publisher;
    modalPublishDateInput.value = item.publishDate;
    modalTotalPages.value = item.totalPages || '';
    modalReadPages.value = item.readPages || '';
    modalOverlay.classList.add('show');
    modalTitleInput.focus();
    modalIdInput.readOnly = true;
  }

  function closeModal() {
    modalOverlay.classList.remove('show');
  }

  modalCloseBtn.addEventListener('click', () => {
    closeModal();
  });

  modalForm.addEventListener('submit', e => {
    e.preventDefault();
    const item = {
      type: modalType.value,
      id: modalIdInput.value.trim(),
      title: modalTitleInput.value.trim(),
      authors: modalAuthorsInput.value.trim(),
      publisher: modalPublisherInput.value.trim(),
      publishDate: modalPublishDateInput.value.trim(),
      totalPages: modalTotalPages.value.trim(),
      readPages: modalReadPages.value.trim(),
    };
    // 计算进度
    const totalPagesNum = Number(item.totalPages);
    const readPagesNum = Number(item.readPages);
    let progress = 0;
    if (totalPagesNum > 0 && readPagesNum >= 0) {
      progress = Math.min(100, Math.round((readPagesNum / totalPagesNum) * 100));
    }
    item.progress = progress;

    if (!item.title || !item.authors) {
      alert('标题和作者为必填项');
      return;
    }
	const idx = books.findIndex(b => b.id === item.id);
	if (idx !== -1) {
	  // 更新已有条目
	  books[idx] = item;
	  showToast(`${item.type}已更新`);
	} else {
	  // 新增条目
	  books.push(item);
	  showToast(`${item.type}已添加`);
	}
	saveBooks();
	renderTable(filterInput.value);
	closeModal();
  });

  let toastTimeout;
  function showToast(text) {
    if (toastTimeout) clearTimeout(toastTimeout);
    toast.textContent = text;
    toast.classList.add('show');
    toastTimeout = setTimeout(() => {
      toast.classList.remove('show');
    }, 4000);
  }

  btnIsbnSearch.addEventListener('click', async () => {
    const isbn = isbnInput.value.trim();
    if (!isbn) {
      alert('请输入ISBN');
      return;
    }
    showLoading(true);
    const info = await fetchBookInfo(isbn);
    showLoading(false);
    if (info) {
      if (books.some(b => b.id === info.id)) {
        alert('该图书已存在列表中');
        return;
      }
      addBook(info);
      showToast('图书已添加');
    } else {
      if (confirm('未找到对应图书信息，是否手动录入？')) {
        modalType.value = '图书';
        modalIdInput.value = isbn;
        modalTitleInput.value = '';
        modalAuthorsInput.value = '';
        modalPublisherInput.value = '';
        modalPublishDateInput.value = '';
        modalTotalPages.value = '';
        modalReadPages.value = '';
        modalOverlay.classList.add('show');
        modalTitleInput.focus();
        modalIdInput.readOnly = false;
      }
    }
  });

  btnDoiSearch.addEventListener('click', async () => {
    const doi = doiInput.value.trim();
    if (!doi) {
      alert('请输入DOI');
      return;
    }
    showLoading(true);
    const info = await fetchPaperInfo(doi);
    showLoading(false);
    if (info) {
      if (books.some(b => b.id === info.id)) {
        alert('该论文已存在列表中');
        return;
      }
      addBook(info);
      showToast('论文已添加');
    } else {
      if (confirm('未找到对应论文信息，是否手动录入？')) {
        modalType.value = '论文';
        modalIdInput.value = doi;
        modalTitleInput.value = '';
        modalAuthorsInput.value = '';
        modalPublisherInput.value = '';
        modalPublishDateInput.value = '';
        modalTotalPages.value = '';
        modalReadPages.value = '';
        modalOverlay.classList.add('show');
        modalTitleInput.focus();
        modalIdInput.readOnly = false;
      }
    }
  });

  function showLoading(flag) {
    btnIsbnSearch.disabled = flag;
    btnDoiSearch.disabled = flag;
    btnIsbnSearch.textContent = flag ? '搜索中...' : '搜索图书';
    btnDoiSearch.textContent = flag ? '搜索中...' : '搜索论文';
  }

  function updateSortIndicators() {
    document.querySelectorAll('th.sortable').forEach(th => {
      th.textContent = th.textContent.replace(/[\u25B2\u25BC]/g, '');
      const field = th.getAttribute('data-field');
      if (field === currentSort.field) {
        th.textContent += currentSort.direction === 1 ? ' ▲' : ' ▼';
      }
    });
  }

  document.querySelectorAll('th.sortable').forEach(th => {
    th.addEventListener('click', () => {
      const field = th.getAttribute('data-field');
      if (currentSort.field === field) {
        currentSort.direction = -currentSort.direction;
      } else {
        currentSort.field = field;
        currentSort.direction = 1;
      }
      updateSortIndicators();
      renderTable(filterInput.value);
    });
  });

  function loadBooks() {
    const data = localStorage.getItem('booksData');
    if (data) {
      try {
        books = JSON.parse(data);
      } catch {
        books = [];
      }
    }
  }

  loadBooks();
  updateSortIndicators();
  renderTable('');

  // 初始化tab
  switchTab(0);

  // 拖拽滑块
  let isDragging = false;
  let dragStartX = 0;
  let sliderStartLeft = 0;

  slider.addEventListener('mousedown', e => {
    isDragging = true;
    dragStartX = e.clientX;
    sliderStartLeft = parseFloat(slider.style.left) || 0;
    slider.style.transition = 'none';
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      slider.style.transition = 'left 0.3s ease';
      // 根据位置决定选中哪个tab
      const leftPercent = parseFloat(slider.style.left);
      if (leftPercent < 25) switchTab(0);
      else switchTab(1);
    }
  });

  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const deltaX = e.clientX - dragStartX;
    let newLeftPx = sliderStartLeft / 100 * window.innerWidth + deltaX;
    newLeftPx = Math.min(Math.max(newLeftPx, 0), window.innerWidth / 2);
    slider.style.left = (newLeftPx / window.innerWidth) * 100 + '%';
  });

})();
</script>
</body>
</html>


